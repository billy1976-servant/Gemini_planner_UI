/**
 * verify-atoms-manifest.ts
 * Loads src/blocks/atoms.manifest.json and src/components/9-atoms/definitions/*.json,
 * validates each manifest atom matches its source file by deep equality.
 * Outputs src/cursor/ATOMS_MANIFEST_VERIFICATION_REPORT.md
 * No runtime changes; script-only.
 */

import fs from "fs";
import path from "path";

const ROOT = process.cwd();
const MANIFEST_PATH = path.join(ROOT, "src/blocks/atoms.manifest.json");
const DEFINITIONS_DIR = path.join(ROOT, "src/components/9-atoms/definitions");
const REPORT_PATH = path.join(ROOT, "src/cursor/ATOMS_MANIFEST_VERIFICATION_REPORT.md");

function loadJson(filePath: string): unknown {
  const raw = fs.readFileSync(filePath, "utf-8");
  return JSON.parse(raw);
}

function deepEqual(a: unknown, b: unknown): boolean {
  return JSON.stringify(a) === JSON.stringify(b);
}

function diffKeys(
  a: Record<string, unknown>,
  b: Record<string, unknown>
): { onlyInA: string[]; onlyInB: string[]; valueDiffs: { key: string; inA: unknown; inB: unknown }[] } {
  const onlyInA: string[] = [];
  const onlyInB: string[] = [];
  const valueDiffs: { key: string; inA: unknown; inB: unknown }[] = [];
  const allKeys = new Set([...Object.keys(a), ...Object.keys(b)]);
  for (const key of allKeys) {
    if (!(key in b)) {
      onlyInA.push(key);
      continue;
    }
    if (!(key in a)) {
      onlyInB.push(key);
      continue;
    }
    const va = a[key];
    const vb = b[key];
    if (!deepEqual(va, vb)) {
      valueDiffs.push({ key, inA: va, inB: vb });
    }
  }
  return { onlyInA, onlyInB, valueDiffs };
}

function describeDiff(
  manifestDef: Record<string, unknown>,
  sourceDef: Record<string, unknown>
): string[] {
  const lines: string[] = [];
  const { onlyInA, onlyInB, valueDiffs } = diffKeys(manifestDef, sourceDef);
  if (onlyInA.length) {
    lines.push(`- Only in manifest: ${onlyInA.join(", ")}`);
  }
  if (onlyInB.length) {
    lines.push(`- Only in source: ${onlyInB.join(", ")}`);
  }
  for (const { key, inA, inB } of valueDiffs) {
    lines.push(`- Differ on "${key}": manifest=${JSON.stringify(inA)}, source=${JSON.stringify(inB)}`);
  }
  return lines;
}

function main() {
  const manifest = loadJson(MANIFEST_PATH) as { atoms: Record<string, Record<string, unknown>> };
  const atoms = manifest.atoms;
  if (!atoms || typeof atoms !== "object") {
    throw new Error("atoms.manifest.json must have an 'atoms' object");
  }

  const definitionFiles = fs.readdirSync(DEFINITIONS_DIR).filter((f) => f.endsWith(".json"));
  const results: { id: string; status: "PASS" | "FAIL"; details: string[] }[] = [];

  for (const file of definitionFiles.sort()) {
    const id = path.basename(file, ".json");
    const sourcePath = path.join(DEFINITIONS_DIR, file);
    const sourceDef = loadJson(sourcePath) as Record<string, unknown>;
    const manifestDef = atoms[id];

    if (manifestDef === undefined) {
      results.push({
        id,
        status: "FAIL",
        details: ["Atom present in source but missing in manifest."],
      });
      continue;
    }

    if (deepEqual(manifestDef, sourceDef)) {
      results.push({ id, status: "PASS", details: [] });
      continue;
    }

    const details = describeDiff(manifestDef as Record<string, unknown>, sourceDef);
    results.push({ id, status: "FAIL", details });
  }

  const manifestOnly = Object.keys(atoms).filter(
    (k) => !definitionFiles.includes(`${k}.json`)
  );
  for (const id of manifestOnly) {
    results.push({
      id,
      status: "FAIL",
      details: ["Atom present in manifest but no source file in definitions."],
    });
  }

  const reportLines: string[] = [
    "# Atoms Manifest Verification Report",
    "",
    "Generated by `scripts/verify-atoms-manifest.ts`",
    "",
    "## Summary",
    "",
    `- Manifest: \`src/blocks/atoms.manifest.json\``,
    `- Source: \`src/components/9-atoms/definitions/*.json\``,
    `- Total atoms in manifest: ${Object.keys(atoms).length}`,
    `- Total source files: ${definitionFiles.length}`,
    `- PASS: ${results.filter((r) => r.status === "PASS").length}`,
    `- FAIL: ${results.filter((r) => r.status === "FAIL").length}`,
    "",
    "## Per-atom result",
    "",
    "| Atom | Status | Details |",
    "|------|--------|--------|",
  ];

  for (const { id, status, details } of results.sort((a, b) => a.id.localeCompare(b.id))) {
    const detailCell = details.length ? details.join("; ") : "â€”";
    reportLines.push(`| ${id} | ${status} | ${detailCell} |`);
  }

  reportLines.push("");

  const reportDir = path.dirname(REPORT_PATH);
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  fs.writeFileSync(REPORT_PATH, reportLines.join("\n"), "utf-8");
  console.log("Report written to", REPORT_PATH);
}

main();

/**
 * verify-atoms-manifest.ts
 * Loads src/components/atoms/atoms.json (single source for 9 atoms).
 * Validates atom keys and structure.
 * Outputs src/cursor/ATOMS_MANIFEST_VERIFICATION_REPORT.md
 * No runtime changes; script-only.
 */

import fs from "fs";
import path from "path";

const ROOT = process.cwd();
const ATOMS_JSON_PATH = path.join(ROOT, "src/components/atoms/atoms.json");
const REPORT_PATH = path.join(ROOT, "src/cursor/ATOMS_MANIFEST_VERIFICATION_REPORT.md");

function loadJson(filePath: string): unknown {
  const raw = fs.readFileSync(filePath, "utf-8");
  return JSON.parse(raw);
}

function deepEqual(a: unknown, b: unknown): boolean {
  return JSON.stringify(a) === JSON.stringify(b);
}

function diffKeys(
  a: Record<string, unknown>,
  b: Record<string, unknown>
): { onlyInA: string[]; onlyInB: string[]; valueDiffs: { key: string; inA: unknown; inB: unknown }[] } {
  const onlyInA: string[] = [];
  const onlyInB: string[] = [];
  const valueDiffs: { key: string; inA: unknown; inB: unknown }[] = [];
  const allKeys = new Set([...Object.keys(a), ...Object.keys(b)]);
  for (const key of allKeys) {
    if (!(key in b)) {
      onlyInA.push(key);
      continue;
    }
    if (!(key in a)) {
      onlyInB.push(key);
      continue;
    }
    const va = a[key];
    const vb = b[key];
    if (!deepEqual(va, vb)) {
      valueDiffs.push({ key, inA: va, inB: vb });
    }
  }
  return { onlyInA, onlyInB, valueDiffs };
}

function describeDiff(
  manifestDef: Record<string, unknown>,
  sourceDef: Record<string, unknown>
): string[] {
  const lines: string[] = [];
  const { onlyInA, onlyInB, valueDiffs } = diffKeys(manifestDef, sourceDef);
  if (onlyInA.length) {
    lines.push(`- Only in manifest: ${onlyInA.join(", ")}`);
  }
  if (onlyInB.length) {
    lines.push(`- Only in source: ${onlyInB.join(", ")}`);
  }
  for (const { key, inA, inB } of valueDiffs) {
    lines.push(`- Differ on "${key}": manifest=${JSON.stringify(inA)}, source=${JSON.stringify(inB)}`);
  }
  return lines;
}

const EXPECTED_ATOM_IDS = ["collection", "condition", "field", "media", "sequence", "shell", "surface", "text", "trigger"];

function main() {
  if (!fs.existsSync(ATOMS_JSON_PATH)) {
    throw new Error(`atoms.json not found: ${ATOMS_JSON_PATH}`);
  }
  const data = loadJson(ATOMS_JSON_PATH) as { atoms: Record<string, unknown> };
  const atoms = data?.atoms;
  if (!atoms || typeof atoms !== "object") {
    throw new Error("atoms.json must have an 'atoms' object");
  }

  const results: { id: string; status: "PASS" | "FAIL"; details: string[] }[] = [];
  for (const id of EXPECTED_ATOM_IDS) {
    if (atoms[id] !== undefined) {
      results.push({ id, status: "PASS", details: [] });
    } else {
      results.push({ id, status: "FAIL", details: ["Missing in atoms.json"] });
    }
  }
  const extra = Object.keys(atoms).filter((k) => !EXPECTED_ATOM_IDS.includes(k));
  for (const id of extra) {
    results.push({ id, status: "FAIL", details: ["Not in contract (expected 9 atoms only)"] });
  }

  const reportLines: string[] = [
    "# Atoms Manifest Verification Report",
    "",
    "Generated by `scripts/verify-atoms-manifest.ts`",
    "",
    "## Summary",
    "",
    `- Source: \`src/components/atoms/atoms.json\``,
    `- Expected atoms: ${EXPECTED_ATOM_IDS.length}`,
    `- PASS: ${results.filter((r) => r.status === "PASS").length}`,
    `- FAIL: ${results.filter((r) => r.status === "FAIL").length}`,
    "",
    "## Per-atom result",
    "",
    "| Atom | Status | Details |",
    "|------|--------|--------|",
  ];

  for (const { id, status, details } of results.sort((a, b) => a.id.localeCompare(b.id))) {
    const detailCell = details.length ? details.join("; ") : "â€”";
    reportLines.push(`| ${id} | ${status} | ${detailCell} |`);
  }

  reportLines.push("");

  const reportDir = path.dirname(REPORT_PATH);
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  fs.writeFileSync(REPORT_PATH, reportLines.join("\n"), "utf-8");
  console.log("Report written to", REPORT_PATH);
}

main();

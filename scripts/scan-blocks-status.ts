/**
 * scan-blocks-status.ts
 * Generates src/cursor/BLOCKS_STATUS_REPORT.md with:
 * - Atom count from src/components/atoms/atoms.json
 * - Molecule (compound) runtime TSX count from src/components/molecules
 * - Registry drift: molecules.json paths checked for existence; list missing
 * No runtime changes.
 */

import fs from "fs";
import path from "path";

const ROOT = process.cwd();
const ATOMS_JSON_PATH = path.join(ROOT, "src/components/atoms/atoms.json");
const MOLECULES_DIR = path.join(ROOT, "src/components/molecules");
const MOLECULES_REGISTRY_PATH = path.join(ROOT, "src/registry/molecules.json");
const ENGINE_REGISTRY_PATH = path.join(ROOT, "src/engine/core/registry.tsx");
const REPORT_PATH = path.join(ROOT, "src/cursor/BLOCKS_STATUS_REPORT.md");

function loadJson(filePath: string): unknown {
  const raw = fs.readFileSync(filePath, "utf-8");
  return JSON.parse(raw);
}

/** Resolve @/ to src/ for path existence check */
function resolvePath(aliasPath: string): string {
  const normalized = aliasPath.replace(/^@\//, "src/");
  return path.join(ROOT, normalized);
}

/** Check if a registry component path exists (with or without extension) */
function componentPathExists(aliasPath: string): boolean {
  const base = resolvePath(aliasPath);
  if (fs.existsSync(base)) return true;
  if (fs.existsSync(base + ".tsx")) return true;
  if (fs.existsSync(base + ".ts")) return true;
  return false;
}

/** Check if a defs path exists */
function defsPathExists(aliasPath: string): boolean {
  return fs.existsSync(resolvePath(aliasPath));
}

function main() {
  const lines: string[] = [
    "# Blocks Status Report",
    "",
    "Generated by `scripts/scan-blocks-status.ts`",
    "",
    "## Atom counts",
    "",
  ];

  let atomCount = 0;
  if (fs.existsSync(ATOMS_JSON_PATH)) {
    const atomsData = loadJson(ATOMS_JSON_PATH) as { atoms: Record<string, unknown> };
    atomCount = atomsData?.atoms ? Object.keys(atomsData.atoms).length : 0;
  }
  lines.push(`- **atoms** (\`src/components/atoms/atoms.json\`): **${atomCount}** atoms`);
  lines.push("");

  lines.push("## Molecule (compound) counts", "");
  const compoundTsxFiles = fs.existsSync(MOLECULES_DIR)
    ? fs.readdirSync(MOLECULES_DIR).filter((f) => f.endsWith(".compound.tsx")).sort()
    : [];
  lines.push(`- **Molecule runtime** (\`src/components/molecules/*.compound.tsx\`): **${compoundTsxFiles.length}** files`);
  lines.push("");
  lines.push("### Molecule TSX files (on disk)", "");
  lines.push(compoundTsxFiles.length ? compoundTsxFiles.join(", ") : "(none)");
  lines.push("");

  const moleculeIds = compoundTsxFiles.map((f) => f.replace(/\.compound\.tsx$/, ""));
  lines.push("## Registry (engine/core/registry.tsx) molecule references", "");
  lines.push("Molecules are resolved via getCompoundComponent from @/components/molecules.");
  lines.push("Molecule ids (from TSX files):", moleculeIds.length ? moleculeIds.join(", ") : "(none)");
  lines.push("");

  lines.push("## Registry drift (src/registry/molecules.json)", "");
  lines.push("Checking whether component and defs paths resolve to existing files.");
  lines.push("");

  const missing: string[] = [];
  const present: string[] = [];

  if (fs.existsSync(MOLECULES_REGISTRY_PATH)) {
    const molecules = loadJson(MOLECULES_REGISTRY_PATH) as Record<
      string,
      { component?: string; defs?: string }
    >;
    for (const [key, entry] of Object.entries(molecules)) {
      if (entry?.component) {
        if (componentPathExists(entry.component)) {
          present.push(`${key}.component: ${entry.component}`);
        } else {
          missing.push(`${key}.component: ${entry.component}`);
        }
      }
      if (entry?.defs) {
        if (defsPathExists(entry.defs)) {
          present.push(`${key}.defs: ${entry.defs}`);
        } else {
          missing.push(`${key}.defs: ${entry.defs}`);
        }
      }
    }
  } else {
    missing.push("(molecules.json not found)");
  }

  lines.push("### Missing paths", "");
  if (missing.length === 0) {
    lines.push("None.");
  } else {
    missing.forEach((p) => lines.push(`- \`${p}\``));
  }
  lines.push("");
  lines.push("### Present paths", "");
  if (present.length === 0) {
    lines.push("None.");
  } else {
    present.forEach((p) => lines.push(`- \`${p}\``));
  }
  lines.push("");

  const reportDir = path.dirname(REPORT_PATH);
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  fs.writeFileSync(REPORT_PATH, lines.join("\n"), "utf-8");
  console.log("Report written to", REPORT_PATH);
}

main();

/**
 * scan-blocks-status.ts
 * Generates src/cursor/BLOCKS_STATUS_REPORT.md with:
 * - Atom count from atoms.manifest
 * - Atom source count from src/components/9-atoms/definitions
 * - Compound count from compounds.manifest
 * - Compound runtime TSX count from src/compounds/ui/12-molecules
 * - Registry drift: molecules.json paths checked for existence; list missing
 * No runtime changes.
 */

import fs from "fs";
import path from "path";

const ROOT = process.cwd();
const ATOMS_MANIFEST_PATH = path.join(ROOT, "src/blocks/atoms.manifest.json");
const ATOM_DEFINITIONS_DIR = path.join(ROOT, "src/components/9-atoms/definitions");
const COMPOUNDS_MANIFEST_PATH = path.join(ROOT, "src/blocks/compounds.manifest.json");
const COMPOUNDS_RUNTIME_DIR = path.join(ROOT, "src/compounds/ui/12-molecules");
const MOLECULES_REGISTRY_PATH = path.join(ROOT, "src/registry/molecules.json");
const ENGINE_REGISTRY_PATH = path.join(ROOT, "src/engine/core/registry.tsx");
const REPORT_PATH = path.join(ROOT, "src/cursor/BLOCKS_STATUS_REPORT.md");

function loadJson(filePath: string): unknown {
  const raw = fs.readFileSync(filePath, "utf-8");
  return JSON.parse(raw);
}

/** Resolve @/ to src/ for path existence check */
function resolvePath(aliasPath: string): string {
  const normalized = aliasPath.replace(/^@\//, "src/");
  return path.join(ROOT, normalized);
}

/** Check if a registry component path exists (with or without extension) */
function componentPathExists(aliasPath: string): boolean {
  const base = resolvePath(aliasPath);
  if (fs.existsSync(base)) return true;
  if (fs.existsSync(base + ".tsx")) return true;
  if (fs.existsSync(base + ".ts")) return true;
  return false;
}

/** Check if a defs path exists */
function defsPathExists(aliasPath: string): boolean {
  return fs.existsSync(resolvePath(aliasPath));
}

function main() {
  const lines: string[] = [
    "# Blocks Status Report",
    "",
    "Generated by `scripts/scan-blocks-status.ts`",
    "",
    "## Atom counts",
    "",
  ];

  const atomsManifest = loadJson(ATOMS_MANIFEST_PATH) as { atoms: Record<string, unknown> };
  const atomCount = atomsManifest?.atoms ? Object.keys(atomsManifest.atoms).length : 0;
  const atomSourceFiles = fs.existsSync(ATOM_DEFINITIONS_DIR)
    ? fs.readdirSync(ATOM_DEFINITIONS_DIR).filter((f) => f.endsWith(".json"))
    : [];
  lines.push(`- **atoms.manifest** (\`src/blocks/atoms.manifest.json\`): **${atomCount}** atoms`);
  lines.push(`- **Atom source** (\`src/components/9-atoms/definitions/*.json\`): **${atomSourceFiles.length}** files`);
  lines.push("");

  lines.push("## Compound counts", "");
  const compoundsManifest = loadJson(COMPOUNDS_MANIFEST_PATH) as {
    compounds?: Record<string, unknown>;
  };
  const compoundIds = compoundsManifest?.compounds
    ? Object.keys(compoundsManifest.compounds).sort()
    : [];
  const compoundCount = compoundIds.length;
  const compoundTsxFiles = fs.existsSync(COMPOUNDS_RUNTIME_DIR)
    ? fs.readdirSync(COMPOUNDS_RUNTIME_DIR).filter((f) => f.endsWith(".compound.tsx")).sort()
    : [];
  lines.push(`- **compounds.manifest** (\`src/blocks/compounds.manifest.json\`): **${compoundCount}** compounds`);
  lines.push(`- **Compound runtime** (\`src/compounds/ui/12-molecules/*.compound.tsx\`): **${compoundTsxFiles.length}** files`);
  lines.push("");
  lines.push("### Compound ids (from manifest)", "");
  lines.push(compoundIds.length ? compoundIds.join(", ") : "(none)");
  lines.push("");
  lines.push("### Compound TSX files (on disk)", "");
  lines.push(compoundTsxFiles.length ? compoundTsxFiles.join(", ") : "(none)");
  lines.push("");

  lines.push("## Registry (engine/core/registry.tsx) compound references", "");
  let registryCompoundCount = 0;
  const registryCompoundIds: string[] = [];
  if (fs.existsSync(ENGINE_REGISTRY_PATH)) {
    const registryContent = fs.readFileSync(ENGINE_REGISTRY_PATH, "utf-8");
    const compoundImportRe = /from ["']@\/compounds\/ui\/12-molecules\/([a-z-]+)\.compound["']/g;
    let m: RegExpExecArray | null;
    while ((m = compoundImportRe.exec(registryContent)) !== null) {
      registryCompoundIds.push(m[1]);
    }
    registryCompoundCount = registryCompoundIds.length;
  }
  lines.push(`- **Compound imports in registry.tsx:** **${registryCompoundCount}**`);
  lines.push("");
  lines.push("Referenced compound ids:", registryCompoundIds.length ? registryCompoundIds.sort().join(", ") : "(none)");
  lines.push("");

  lines.push("## Compound drift", "");
  const inManifestNotRegistry = compoundIds.filter((id) => !registryCompoundIds.includes(id));
  const inRegistryNotManifest = registryCompoundIds.filter((id) => !compoundIds.includes(id));
  lines.push("- **In manifest but not in registry.tsx:** " + (inManifestNotRegistry.length ? inManifestNotRegistry.join(", ") : "none"));
  lines.push("- **In registry.tsx but not in manifest:** " + (inRegistryNotManifest.length ? inRegistryNotManifest.join(", ") : "none"));
  lines.push("");

  lines.push("## Registry drift (src/registry/molecules.json)", "");
  lines.push("Checking whether component and defs paths resolve to existing files.");
  lines.push("");

  const missing: string[] = [];
  const present: string[] = [];

  if (fs.existsSync(MOLECULES_REGISTRY_PATH)) {
    const molecules = loadJson(MOLECULES_REGISTRY_PATH) as Record<
      string,
      { component?: string; defs?: string }
    >;
    for (const [key, entry] of Object.entries(molecules)) {
      if (entry?.component) {
        if (componentPathExists(entry.component)) {
          present.push(`${key}.component: ${entry.component}`);
        } else {
          missing.push(`${key}.component: ${entry.component}`);
        }
      }
      if (entry?.defs) {
        if (defsPathExists(entry.defs)) {
          present.push(`${key}.defs: ${entry.defs}`);
        } else {
          missing.push(`${key}.defs: ${entry.defs}`);
        }
      }
    }
  } else {
    missing.push("(molecules.json not found)");
  }

  lines.push("### Missing paths", "");
  if (missing.length === 0) {
    lines.push("None.");
  } else {
    missing.forEach((p) => lines.push(`- \`${p}\``));
  }
  lines.push("");
  lines.push("### Present paths", "");
  if (present.length === 0) {
    lines.push("None.");
  } else {
    present.forEach((p) => lines.push(`- \`${p}\``));
  }
  lines.push("");

  const reportDir = path.dirname(REPORT_PATH);
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  fs.writeFileSync(REPORT_PATH, lines.join("\n"), "utf-8");
  console.log("Report written to", REPORT_PATH);
}

main();

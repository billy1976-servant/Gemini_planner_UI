# 01 — System Overview

**Source:** Compiled from `src/docs/ARCHITECTURE_AUTOGEN/`, `src/docs/SYSTEM_MAP_AUTOGEN/`, `src/system-reports/summaries/`. No regeneration; read-only consolidation.

---

## What the system is

HiSense is a **JSON-driven UI system**: screens and skins are defined in JSON (blueprint + content), compiled to runtime trees, and rendered by a single engine (JsonRenderer + Registry). Logic and behavior are wired via CustomEvents and an append-only state log. The codebase also includes a **site compiler** (raw snapshot → normalized → schema) and **skin pipeline** (skin JSON → composeScreen → shells → JsonRenderer).

---

## Spine model (authoritative)

Flow: **JSON Screen → Engines → State → Layout → Renderer → DOM**

| Stage | Key files |
|-------|-----------|
| **JSON Screen** | `src/app/page.tsx` (entry; searchParams, loadScreen, resolveLandingPage); `src/app/api/screens/[...path]/route.ts` (GET handler); `src/engine/core/screen-loader.ts` (loadScreen, dispatchState state:currentView if json.state) |
| **Engines** | page.tsx (assignSectionInstanceKeys, expandOrgansInDocument, applySkinBindings, composeOfflineScreen); palette-bridge (applySkinBindings); behavior-listener (action → state:* \| navigate \| runBehavior \| interpretRuntimeVerb); behavior-runner; engine-bridge |
| **State** | `src/state/state-store.ts` (dispatchState, log, persist/rehydrate, listeners); `src/state/state-resolver.ts` (deriveState: currentView, journal, values, layoutByScreen, scans, interactions) |
| **Layout** | `src/layout/resolver/layout-resolver.ts` (resolveLayout, getDefaultSectionLayoutId); `src/layout/index.ts`; `src/engine/core/layout-store.ts`; `src/lib/layout/molecule-layout-resolver.ts` |
| **Renderer** | `src/engine/core/json-renderer.tsx` (JsonRenderer, renderNode, applyProfileToNode, Registry); `src/engine/core/registry.tsx`; section.compound.tsx; LayoutMoleculeRenderer.tsx |
| **DOM** | data-node-id, data-section-id, data-section-layout, data-container-width (json-renderer, LayoutMoleculeRenderer, section.compound) |

---

## Major layers

- **Primary path:** Next.js `page.tsx` → loadScreen (TSX or JSON) → document prep (instance keys, organ expand, skin bindings, compose) → JsonRenderer → Registry → Section/LayoutMoleculeRenderer → DOM.
- **Secondary paths:** renderFromSchema, GeneratedSiteViewer, SiteSkin — used for site/generated-websites or TSX/flow screens; not on main JSON screen path.
- **Blueprint boundary:** Compiler produces app.json + content.manifest.json under `src/apps-offline/apps/<appPath>/`. No blueprint script in runtime; no runtime layout IDs from blueprint. Layout resolution is entirely runtime (override store → node.layout → template default).
- **Scripts boundary:** Scripts under `src/scripts/` (blueprint, docs generators, reachability) are build-time or one-off. No script is imported by app/engine/state/layout at runtime.

---

## Refactor direction

- **Current goal:** Ship shippable website/app skins from the existing JSON→Layout→Regions→Molecules pipeline; lock docs, polish visual shells, connect ripper→skin output, wire behavior/logic — without refactoring engines, molecules, or renderer.
- **Documentation protocol:** CURSOR_SYSTEM_FILES_UPDATE_PROTOCOL.md — diff-first updates to autogenerated docs; no full regeneration without comparing against code.
- **Boundaries:** Layout ≠ Logic ≠ State ≠ Behavior ≠ Blueprint ≠ Organs ≠ Registry; no cross-boundary writes (see BOUNDARY_SEPARATION_CHECKLIST).

---

## Where things live

| What | Where |
|------|--------|
| Screens (JSON) | `src/apps-offline/apps/<category>/<folder>/` (app.json). Served via `/api/screens/*`. |
| Screens (TSX) | `src/screens/`; loadScreen("tsx:...") returns descriptor, no fetch. |
| Skins | Skin JSON: loadSiteSkin (e.g. /api/sites/:domain/skins/:pageId). Compiled skins under `src/content/sites/*/compiled/skins/`. Shells: WebsiteShell, AppShell, LearningShell in `src/lib/site-skin/shells/`. |
| Logic/behavior | behavior-listener, behavior-runner, state-store, state-resolver, runtime-verb-interpreter, action-runner, action-registry. |
| Layout | layout/resolver, layout-store, section-layout-preset-store, organ-internal-layout-store; page-layouts, templates, component-layouts, compatibility. |
| Organs | `src/organs/` (resolve-organs, organ-registry, expandOrgansInDocument, loadOrganVariant); `src/layout-organ/`. |
| Contracts | `src/contracts/` (ENGINE_LAWS, PARAM_KEY_MAPPING, BLUEPRINT_UNIVERSE, CONTENT_DERIVATION, JSON_SCREEN_CONTRACT). |
| Adapters | Product-to-screen: `src/lib/product-screen-adapter/`; script: `npm run product-screen -- <domain>`. |

---

## Data flow (transform vs display)

- **Blueprint (build):** Transform: source → app.json; not at runtime.
- **API:** Read file; no transform.
- **loadScreen:** Transform: apply default state only.
- **page (root → finalChildren):** Transform: instance keys, organ expand, skin bindings, compose, optional layout-node collapse.
- **applyProfileToNode:** Transform: section layout id (override → node.layout → template default); strip section layout params; merge card preset, spacing, profile.
- **renderNode:** Transform: when/visibility, repeater mapping, field/journal injection; display via Registry.
- **Section / LayoutMoleculeRenderer:** Display (layout structure).
- **Registry components:** Display only. Filtering/mapping: shouldRenderNode (when/state), repeater (items → nodes), expandOrgans (organ → variant tree), resolveSlotNode (slot → data[slotKey]), evaluateCompatibility (required vs available slots).

---

## Boundary separation (no cross-boundary writes)| Boundary | Scope | Primary locations |
|----------|--------|-------------------|
| Layout | Layout resolution, resolveLayout, LAYOUT_NODE_TYPES, collapse-layout-nodes | src/layout/, src/engine/core/collapse-layout-nodes.ts |
| Logic | Runtime verbs, action-runner, action-registry, flows, engines, content resolution | src/logic/ |
| State | dispatchState, deriveState, event log, persistence, intents | src/state/ |
| Behavior | behavior-listener, runBehavior, contract verbs, navigate, input-change | src/engine/core/behavior-listener.ts, src/behavior/ |
| Blueprint | Compiler output; build-time only | src/scripts/blueprint.ts; not imported at runtime |
| Organs | Organ registry, expandOrgansInDocument, organ variants, internal layout | src/organs/, src/layout-organ/ |
| Registry | JSON type → React component; read-only | src/engine/core/registry.tsx |

**Rule:** Layout must not write to state/behavior/logic; Logic must not write layout IDs or override stores; State must not mutate layout/registry/blueprint; Behavior must not resolve layout/organs; Blueprint build-time only; Organs read config only; Registry read-only. **Integration:** Defined APIs only — e.g. dispatchState (state), runBehavior / interpretRuntimeVerb (behavior → logic/state), applyProfileToNode (layout from profile/override), loadScreen (screen doc → state default).

---

## Governance / protocol

- **Checklist (when changing code):** Does this change write from one boundary into another? Use documented integration point or add to BOUNDARY_SEPARATION_CHECKLIST. Does it add a new cross-boundary dependency? Document in PIPELINE_AND_BOUNDARIES_REFERENCE or STATE_MUTATION_SURFACE_MAP.
- **Phase 10 sign-off (boundary check):** No layout in state; no behavior in layout; no blueprint in runtime; JSON authority / JsonRenderer primary; separation checklist documented. Ref: REFRACTOR_EXECUTION_MASTER_ROADMAP Part I D.

# Runtime Call Graph (Execution Truth)

Autogenerated diagnostic: real execution chain only. File paths and function names for every hop. Engines not in the call chain are listed at the end.

---

## Stage 1 — App Entry

**File:** `src/app/layout.tsx`  
**Function:** `RootLayout` (default export)

**Calls:**
- `usePaletteCSS()` from `@/lib/site-renderer/palette-bridge`
- `setLayout`, `getLayout`, `subscribeLayout` from `@/engine/core/layout-store`
- `getCurrentScreenTree` from `@/engine/core/current-screen-tree-store`
- `getTemplateList` from `@/lib/layout/template-profiles`
- `dispatchState` from `@/state/state-store`
- `installBehaviorListener(navigate)` from `@/engine/core/behavior-listener` (in `useEffect`; `navigate` calls `router.replace(/?screen=...)` or `dispatchState("state:currentView", { value })`)
- `setLayout({ experience })` when experience changes
- `fetch("/api/screens")` for screen index
- Renders `{children}` → **Page** component

---

**File:** `src/app/page.tsx`  
**Function:** `Page` (default export)

**Calls:**
- `useSearchParams().get("screen")`, `.get("flow")`
- `loadScreen(path)` from `@/engine/core/screen-loader` (when `screen` or flow param present)
- `resolveLandingPage()` from `@/logic/runtime/landing-page-resolver` (when no screen, no flow)
- `resolveTsxScreen(path)` (local) for TSX screen component
- `assignSectionInstanceKeys`, `expandOrgansInDocument` from `@/organs/resolve-organs`
- `loadOrganVariant` from `@/organs/organ-registry`
- `applySkinBindings` from `@/logic/bridges/skinBindings.apply`
- `getExperienceProfile`, `getTemplateProfile` from `@/lib/layout/profile-resolver`, `@/lib/layout/template-profiles`
- `composeOfflineScreen` from `@/lib/screens/compose-offline-screen`
- `setCurrentScreenTree` from `@/engine/core/current-screen-tree-store`
- `hasLayoutNodeType`, `collapseLayoutNodes` from `@/engine/core/collapse-layout-nodes`
- Override stores: `getOverridesForScreen`, `getCardOverridesForScreen`, `getOrganInternalLayoutOverridesForScreen`, etc. from `@/state/section-layout-preset-store`, `@/state/organ-internal-layout-store`
- `getLayout2Ids`, `collectSectionKeysAndNodes`, `collectSectionLabels` from `@/layout`; `getOrganLayoutOrganIds`, `getInternalLayoutIds` from `@/layout-organ`
- `<JsonRenderer key={renderKey} node={treeForRender} ... />` from `@/engine/core/json-renderer`
- Shells: `WebsiteShell`, `AppShell`, `LearningShell` from `@/lib/site-skin/shells/*`
- `SectionLayoutDropdown`, `OrganPanel` (dev/overlay)

---

## Stage 2 — Screen Resolution

**File:** `src/app/page.tsx`  
**Function:** `Page` (useEffect, dependency `[screen, searchParams]`)

**Calls:**
- If no `screen`: `resolveLandingPage()` or `loadScreen("tsx:tsx-screens/onboarding/engine-viewer")` when `flow` param present
- If `screen`: `loadScreen(screen)`

---

**File:** `src/logic/runtime/landing-page-resolver.ts`  
**Function:** `resolveLandingPage`

**Calls:**
- `getState()` from `@/state/state-store`
- `readEngineState()` from `./engine-bridge`
- `resolveOnboardingFromAnswers(answers)` from `@/logic/engines/Onboarding-flow-router`
- `resolveContent("construction-cleanup")` from `@/logic/content/content-resolver`

**Returns:** `{ content, flow }`

---

**File:** `src/engine/core/screen-loader.ts`  
**Function:** `loadScreen(path)`

**Calls:**
- TSX branch: return `{ __type: "tsx-screen", path }` (no network)
- JSON branch: `fetch(\`/api/screens/${normalized}?t=...\`, { cache: "no-store" })`; on response, optionally `dispatchState("state:currentView", { value: json.state.currentView })` from `@/state/state-store`; return parsed JSON

---

**File:** `src/app/api/screens/[...path]/route.ts`  
**Function:** `GET(_req, { params })`

**Calls:**
- `path.join(SCREENS_ROOT, ...params.path)` for JSON; `fs.existsSync`, `fs.readFileSync` for file under `src/apps-offline/apps`
- For TSX: `path.join(TSX_ROOT, ...params.path)` + `.screen.tsx` under `src/screens`; if exists, return `{ __tsx__: true, screen: requestedPath }` (or marker for TSX)

---

## Stage 3 — Layout Resolution

**File:** `src/engine/core/json-renderer.tsx`  
**Function:** `applyProfileToNode(node, profile, sectionLayoutPresetOverrides, cardLayoutPresetOverrides, parentSectionKey, organInternalLayoutOverrides)`

**Calls:**
- `getDefaultSectionLayoutId(templateId)` from `@/layout` (re-exported from `src/layout/resolver/layout-resolver.ts` → page)
- `evaluateCompatibility({ sectionNode, sectionLayoutId, cardLayoutId, organId, organInternalLayoutId })` from `@/layout` (re-exported from `src/layout/compatibility`)
- `getCardLayoutPreset(cardPresetId)` from `@/lib/layout/card-layout-presets`
- Recurses over `node.children` with `applyProfileToNode`

**Layout ID precedence (in applyProfileToNode):** overrideId → existingLayoutId (node.layout) → templateDefaultLayoutId (profile.defaultSectionLayoutId or getDefaultSectionLayoutId) → undefined

---

**File:** `src/layout/resolver/layout-resolver.ts`  
**Function:** `resolveLayout(layout, context?)`

**Calls:**
- `getPageLayoutId(layout, context)` from `@/layout/page`
- `getPageLayoutById(layoutId)` from `@/layout/page`
- `resolveComponentLayout(layoutId)` from `@/layout/component`

**Returns:** `LayoutDefinition | null` (merged page + component)

---

**File:** `src/layout/page/page-layout-resolver.ts`  
**Functions:** `getPageLayoutId`, `getPageLayoutById`, `getPageLayoutIds`, `getDefaultSectionLayoutId`  
**Data:** `page-layouts.json` (or equivalent)

---

**File:** `src/layout/component/component-layout-resolver.ts`  
**Function:** `resolveComponentLayout(layoutId)`  
**Data:** `component-layouts.json`

---

**File:** `src/layout/compatibility/compatibility-evaluator.ts`  
**Function:** `evaluateCompatibility(args)`  
**Calls:** `getAvailableSlots(sectionNode)` from `content-capability-extractor.ts`; `getRequiredSlots`, `getRequiredSlotsForOrgan` from `requirement-registry.ts`

---

**File:** `src/compounds/ui/12-molecules/section.compound.tsx`  
**Function:** `SectionCompound` (default export)

**Calls:**
- `resolveLayout(layout)` from `@/layout`
- `getOrganLayoutOrganIds`, `resolveInternalLayoutId` from `@/layout-organ`
- `loadOrganVariant` from `@/organs/organ-registry`
- When `layoutDef !== null`: `<LayoutMoleculeRenderer ... />` from `@/layout`; else renders `<div data-section-id={id}>{children}</div>`

---

## Stage 4 — Render Pipeline

**File:** `src/engine/core/json-renderer.tsx`  
**Function:** `JsonRenderer` (default export)

**Calls:**
- `useSyncExternalStore(subscribeLayout, getLayout, getLayout)`, `useSyncExternalStore(subscribeState, getState, getState)`, `useSyncExternalStore(subscribePalette, ...)`, override store subscriptions
- `applyProfileToNode(node, profile, ...)` (sets section layout id, card preset, compatibility log in dev)
- `renderNode(node, profile, stateSnapshot, defaultState, ...)` for root and recursion

---

**File:** `src/engine/core/json-renderer.tsx`  
**Function:** `renderNode(node, profile, stateSnapshot, defaultState, sectionLayoutPresetOverrides, cardLayoutPresetOverrides, organInternalLayoutOverrides)`

**Calls:**
- If `node.type === "json-skin"`: `<JsonSkinEngine screen={node} />` from `@/logic/engines/json-skin.engine`
- `shouldRenderNode(node, stateSnapshot, defaultState)` (when/state/equals)
- `applyProfileToNode(node, profile, ...)` for section/card layout and preset
- `definitions[type]` from `@/compounds/ui/index`; `Registry[type]` from `./registry`
- For `node.items`: map to Card nodes, `renderNode` per item
- For `node.children`: map and `renderNode` per child
- Returns `<Component {...resolvedNode} />` (Registry component)

---

**File:** `src/engine/core/registry.tsx`  
**Role:** Maps JSON `type` string → React component (atoms/molecules/section/card/grid etc.)

---

**File:** `src/layout/renderer/LayoutMoleculeRenderer.tsx`  
**Function:** `LayoutMoleculeRenderer`  
**Called by:** Section compound when `layoutDef !== null`  
**Role:** Renders section layout structure (surface, split/grid/column) and children

---

**File:** `src/logic/engines/json-skin.engine.tsx`  
**Role:** Renders `type === "json-skin"` nodes (e.g. landing page blocks)

---

## Stage 5 — Behavior Dispatch

**File:** `src/app/layout.tsx`  
**In useEffect:** `installBehaviorListener((to) => { ... router.replace(/?screen=...) or dispatchState("state:currentView", { value: to }) })`

---

**File:** `src/engine/core/behavior-listener.ts`  
**Function:** `installBehaviorListener(navigate)`

**Listens:**
- `window.addEventListener("navigate", ...)`: reads `e.detail.to` / `screenId` / `target` → calls `navigate(destination)`
- `window.addEventListener("input-change", ...)`: captures value/fieldKey; may call `dispatchState("state.update", { key: fieldKey, value })`
- `window.addEventListener("action", ...)`:
  - If `params.name.startsWith("state:")`: resolve value (input/state), then `dispatchState(...)` for currentView, state.update, journal.add (from `@/state/state-store`)
  - If `params.name === "navigate"`: `navigate(params.to)`
  - If `params.name` is contract verb (tap, double, long, drag, scroll, swipe, go, back, open, close, route, crop, filter, frame, layout, motion, overlay): `runBehavior(domain, actionName, { navigate }, params)` from `@/behavior/behavior-runner`
  - Else: `require("../../logic/runtime/runtime-verb-interpreter")` → `interpretRuntimeVerb({ name: actionName, ...params }, getState())`

---

**File:** `src/behavior/behavior-runner.ts`  
**Function:** `runBehavior(domain, action, ctx, args)`  
**Calls:** `resolveBehaviorVerb(domain, action)`; looks up `BehaviorEngine[handlerName]`; calls handler; navigation domain may call `fireNavigation(ctx, result?.target ?? args?.target)`

---

**File:** `src/logic/runtime/runtime-verb-interpreter.ts`  
**Function:** `interpretRuntimeVerb(verb, state)`  
**Role:** Normalizes and forwards to action-runner / runtime handlers

---

## Stage 6 — State Update

**File:** `src/state/state-store.ts`  
**Function:** `dispatchState(intent, payload)`

**Calls:**
- Appends `{ intent, payload }` to `log`
- `deriveState(log)` from `@/state/state-resolver`
- Sets `state = result`; notifies listeners
- If `intent !== "state.update"`: `persist()` (writes log to localStorage)

---

**File:** `src/state/state-resolver.ts`  
**Function:** `deriveState(log)`

**Handles intents:** `state:currentView`, `journal.set`, `journal.add`, `state.update`, `scan.result`, `scan.interpreted`, `interaction.record`  
**Returns:** Derived state shape used by `getState()`

---

## Engines NOT Reached During Runtime

The following are documented or exist in the repo but **do not participate** in the main execution path (Next.js layout → page → screen load → layout resolution → JsonRenderer → behavior → state):

| Engine / System | Notes |
|-----------------|--------|
| **Layout Decision Engine** | Documented in ARCHITECTURE_AUTOGEN; no implementation. Would score/rank compatible layout IDs by traits; not called from resolver or applyProfileToNode. |
| **User Preference Adaptation** | Documented; no implementation. Would persist trait weights from "more/less like this" signals; no preference memory or wiring. |
| **Suggestion Injection Point** | Documented; no implementation. Resolver never calls Logic for a suggested layout ID; precedence is override → explicit → template default only. |
| **Contextual Layout Logic** | Documented; no implementation. Would map content structure to trait suggestions; no rules or engine in code. |
| **Trait Registry System** | Documented; no implementation. No trait-registry.json or layout-traits.json loader; no layout ID → traits lookup in runtime. |
| **Explainability / Trace** | Documented (Plan 10); no explanation object produced by resolver; no structured trace (source, layoutId, suggestionDetail) in code. |
| **Engine Registry (getPresentation, applyEngine)** | Exists in `src/logic/engine-system/engine-registry.ts`. Reached only when a TSX screen or flow is loaded (e.g. engine-viewer, flow-loader, OnboardingFlowRenderer, FlowRenderer). **Not** on the main JSON screen path (page.tsx → loadScreen → JsonRenderer). |

---

*Autogenerated from code/docs scan. Re-run tracing to refresh.*

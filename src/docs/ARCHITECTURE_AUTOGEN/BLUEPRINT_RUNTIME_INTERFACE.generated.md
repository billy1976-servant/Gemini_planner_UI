# BLUEPRINT_RUNTIME_INTERFACE.generated.md

Trace: blueprint compiler → app.json → loadScreen → renderer. What compiler outputs, what runtime expects, fields that must not be generated by the compiler, and files that validate/normalize.

---

## Compiler output (blueprint script)

| File path | Role |
|-----------|------|
| `src/scripts/blueprint.ts` | CLI: parses blueprint + content files, builds tree, writes app.json and content.manifest.json |

**Output files (written by script):**

- `app.json` under app path (e.g. `src/apps-offline/apps/<appPath>/app.json`)
- `content.manifest.json` (same dir) — generated from ALLOWED_CONTENT_KEYS per node type

**Tree shape emitted (buildTree):**

- Node: `id` (slugify(name)), `type`, `children`, `content` (from contentMap)
- Optional: `role` (from node.role), `state` (mode, key), `params` (field), `behavior` (Action/Navigation from logic or target)
- Behavior: Navigation from node.target (-> target); Action from logic (e.g. state:journal.add with track, key, valueFrom, fieldKey) or expr
- No layout ids written by blueprint for sections; role can be set in blueprint

**ALLOWED_CONTENT_KEYS (contract-derived in blueprint):**

button: [label], avatar: [media, text], chip: [title, body, media], field: [label, input, error], list: [items], stepper: [steps], toast: [message], toolbar: [actions], modal: [title, body, actions], section: [title], footer: [left, right], card: [title, body, media, actions]

---

## Runtime load path (app.json → renderer)

| Stage | File path | What happens |
|-------|-----------|--------------|
| URL | User or navigator | `?screen=apps/websites/demo-blueprint-site/app` or normalized path without `apps/` prefix |
| Load | `src/engine/core/screen-loader.ts` | Normalizes path (strip leading /, src/, apps-offline/apps/, apps/); fetches GET /api/screens/{path}.json |
| API | `src/app/api/screens/[...path]/route.ts` | Reads from `path.join(process.cwd(), "src", "apps-offline", "apps", ...params.path)` + `.json`; returns JSON |
| State | `src/engine/core/screen-loader.ts` | If json.state?.currentView, dispatchState("state:currentView", { value }) |
| Page | `src/app/page.tsx` | setJson(data); root = json?.root ?? json?.screen ?? json?.node ?? json; then assignSectionInstanceKeys, expandOrgansInDocument, applySkinBindings, composeOfflineScreen |
| Render | `src/engine/core/json-renderer.tsx` | JsonRenderer(node, defaultState: json?.state, profileOverride, sectionLayoutPresetOverrides, cardLayoutPresetOverrides, organInternalLayoutOverrides) |

---

## What runtime expects (screen document)

- **Root**: Prefer `root`; else `screen`, `node`, or self (with children).
- **Default state**: Optional `state.currentView`; applied on load.
- **Children**: Array of nodes; top-level sections get role inference if missing (composeOfflineScreen / inferRolesFromOfflineTree).
- **data**: Optional; passed to applySkinBindings for skin/organ binding.
- **No screen IDs**: loadScreen forbids paths without "/" and not starting with "tsx:" (no legacy screen-*, calculator-* ids).

---

## Fields compiler must NOT generate (enforced elsewhere)

- **Section layout ids in params**: Runtime strips section params.moleculeLayout, layoutPreset, layout, containerWidth, backgroundVariant, split in applyProfileToNode. Section layout comes from: section layout preset override (store) → node.layout (explicit) → template defaultSectionLayoutId. Blueprint may emit explicit node.layout if desired; otherwise template/organ override applies.
- **Screen id for routing**: Routing is path-based (?screen=path); screen IDs are forbidden in loadScreen.
- **Layout primitive nodes**: Content-only rule; Grid/Row/Column/Stack in JSON trigger dev warning and collapseLayoutNodes rewrite. Blueprint should not emit layout primitives as screen tree nodes for page render.

---

## Validation / normalization (code that touches blueprint output or screen doc)

| File path | Role |
|-----------|------|
| `src/scripts/blueprint.ts` | validateContentKeys(contentMap, manifest, rawNodes) — warns invented/missing content keys per manifest |
| `src/app/api/screens/[...path]/route.ts` | Validates JSON parse; returns 500 on parse error or empty file |
| `src/engine/core/screen-loader.ts` | Validates path (must contain / or tsx:); applies default state |
| `src/app/page.tsx` | hasLayoutNodeType(composed) in dev → collapseLayoutNodes; no schema validation of screen doc |
| `src/contracts/JSON_SCREEN_CONTRACT.json` | Design-time contract (atoms, molecules, behaviorVerbs, rendererExpectations); not imported for runtime validation in traced path |
| `src/lib/screens/compose-offline-screen.ts` | inferRolesFromOfflineTree — infers role for sections without role (header, hero, content, footer by position) |

---

## app.json example shape (from demo-blueprint-site)

- `id`, `type`: "screen"
- `state`: { "currentView": "|home" }
- `data`: nav, header, hero, features, testimonials, pricing, faq, cta, footer (slot blocks for skin/organ expansion)
- Root rendered: from data + organs → expandOrgansInDocument; root node for JsonRenderer is the composed tree (root wrapper with children), not the raw app.json root key. Demo app uses data-driven structure; root/screen/node may be set by compiler or by a separate composition step. For demo-blueprint-site, app.json has data with organ slots; resolve-organs and applySkinBindings produce the actual tree. So compiler may output either a literal root/screen/node tree or a data block for skin binding; runtime composes before render.

---

## Summary

- **Compiler**: blueprint.ts → app.json (+ content.manifest.json); tree nodes have id, type, children, content, optional role/behavior/params; no section layout keys in params; no screen IDs.
- **Runtime expects**: root/screen/node or self, optional state.currentView, optional data; section layout from store/template/node.layout only.
- **Must NOT generate**: section layout in params, screen IDs for load, layout primitive nodes (or they get collapsed in dev).
- **Validation**: blueprint validateContentKeys; API JSON parse; screen-loader path check; compose inferRolesFromOfflineTree; no runtime schema validation of full screen doc in traced path.

## 1.11 — Dropdown Layout Pipeline Repair Plan

**Execution order:** 11 (after 1.10)  
**Classification:** RUNTIME — Pipeline repair (dropdown → behavior → state → layout)  
**Domain:** Layout (UI dropdowns, state pipeline, renderer)  
**Status:** Complete (verification appended; moved to `complete/`)

---

## Scope

This plan repairs the **entire** dropdown → behavior → state → layout pipeline so that:

- All layout-driving dropdowns (global layout controls, section/card/organ presets, dev section layout) use the **existing** runtime pipeline:
  - `CustomEvent("action")` → `behavior-listener` → `state-store` → `JsonRenderer` / layout resolver.
- Layout decisions for dropdown-driven concerns read a **single source of truth** for layout state, not split between local React state, layout-store, and state-store.
- The pipeline is **observable and testable** via the existing Pipeline Debugger (`Pipeline Debugger  LIVE STATE  EVENT LOG`) with deterministic PASS/FAIL checks.

This plan **does not** introduce new UX for dropdown options; option sources remain governed by the already-completed 1.3 Dropdown Source of Truth plan.

---

## Can

- **Can** use the existing `"action"` event and behavior contract:
  - `CustomEvent("action", { detail: { type: "Action", params } })`, with `params.name: "state:update"` and `params.key` / `params.fieldKey` / `params.value`.
- **Can** extend the existing devtools:
  - `InteractionTracerPanel` (Pipeline Debugger) and `PipelineDebugStore` to add a **Tests** view and additional derived diagnostics (state diff, layout diff, render info).
- **Can** refactor or add glue so that:
  - Layout profile and layout overrides are **derived from state** (preferred), or
  - A single synchronizer module mirrors layout-related state keys into the existing layout/preset/palette stores (bridge).
- **Can** introduce or refine tests:
  - Pipeline Debugger tests (runtime, visual/dev).
  - Jest/contract tests that prove the pre-fix failure and post-fix behavior.
- **Can** use the existing `SelectAtom` and JSON renderer bindings to drive state, including dropdowns that set layout-related keys.

---

## Cannot

- **Cannot** introduce any new event types or global listeners beyond the existing:
  - `"action"`, `"navigate"`, `"input-change"`, `"state-mutate"`, and dev-only tracing hooks.
- **Cannot** reintroduce or rely on **non-JSON** layout behavior (no TSX-only layout pipelines as the source of truth).
- **Cannot** add a parallel layout system (e.g. new layout store hierarchy, secondary renderer, or alternative runtime).
- **Cannot** change the layout signal precedence defined in `LAYOUT_SIGNAL_PRIORITY.generated.md`:
  - Explicit `node.layout` → profile overrides → template-role layout → template default → card preset → organ internal defaults → fallback.
- **Cannot** hardcode new layout ids or dropdown options in TS/TSX; layout options remain governed by registries and compatibility (per 1.3).
- **Cannot** break or regress existing working interactions:
  - Journal entry flows.
  - Field value changes.
  - Button behaviors and navigation.

---

## Non-Negotiable Rules

- **Single pipeline only**:
  - All dropdowns must use `CustomEvent("action")` and the existing behavior-listener → state-store bridge.
  - No new side-channel events (e.g. `select-change`, `layout-change`) are allowed.
- **JSON-first / no TSX-only fallbacks**:
  - No new runtime behavior that bypasses JSON-driven engine contracts.
  - Layout must remain JSON-authoritative per the existing layout and registry plans.
- **State as the intended source of truth**:
  - For layout-driving dropdowns, the value that determines layout **must** either:
    - Come directly from `state-store` (preferred), or
    - Be deterministically mirrored from state into legacy stores via a single synchronizer.
- **Trace and test before architecture change**:
  - Root cause must be proven via tests:
    - Show the current failure: dropdown → state diff **without** corresponding layout diff / render evidence.
    - Then show the repaired behavior: dropdown → state diff → layout diff → render tick.
  - Changes to layout/store wiring must only proceed after the failing behavior is pinned in tests.
- **Respect existing layout contracts**:
  - No modifications to the meaning of layout ids, compatibility rules, or registry contents.
  - `applyProfileToNode` continues to implement precedence and never invents layout ids.

---

## Execution Steps

### Step 1 — Document Root Cause

- Create `src/docs/ARCHITECTURE_AUTOGEN/LAYOUT_DROPDOWN_ROOT_CAUSE.md` that:
  - Summarizes key findings from:
    - `DROPDOWN_STATE_PIPELINE_RESTORATION_REPORT.md`
    - `DROPDOWN_ARCH_VERIFICATION.md`
    - `LAYOUT_DECISION_ENGINE.md`
    - `LAYOUT_SIGNAL_PRIORITY.generated.md`
    - `GLOBAL_INTERACTION_PIPELINE_AUDIT.generated.md`
    - `RUNTIME_SYSTEMS_AUDIT.generated.md`
  - Lists all dropdowns and the keys they write (experience, layoutMode, templateId, paletteName, sectionLayoutPreset.*, cardLayoutPreset.*, organInternalLayout.*, devSectionLayout.*).
  - Describes which stores actually drive layout/palette/profile today (layout-store, palette-store, preset override maps, template profiles).
  - Pinpoints the split-brain:
    - State keys updated, but layout and palette read from separate stores and props that are not derived from state.

### Step 2 — Add Truth Tests to Pipeline Debugger

- Extend `InteractionTracerPanel` and `PipelineDebugStore` without changing the event pipeline:
  - Add a **Tests** tab in the existing Pipeline Debugger UI (header: `Pipeline Debugger  LIVE STATE  EVENT LOG`).
  - Implement tests that, after the most recent interaction, report PASS/FAIL (+ reason) using only existing debug snapshots:
    - **Interaction received?**
      - Check `snapshot.lastEvent` (event type + target id).
    - **Behavior action present + name?**
      - Check `snapshot.lastBehavior` and `snapshot.lastAction` for an `"Action"` with `params.name`, especially `"state:update"` for dropdowns.
    - **State diff contains expected key/value?**
      - Use `snapshot.stateDiff` to assert that at least one changed key matches the dropdown’s key (e.g. `values.sectionLayoutPreset.hero`) and that a value changed.
    - **Layout map diff occurred this pass?**
      - Use `snapshot.layoutMap`, `snapshot.previousLayoutMap`, and `snapshot.layoutChangeTrace` to confirm that some section’s layout changed.
    - **Render tick incremented / render evidence present?**
      - Confirm a render pass occurred by checking `snapshot.lastRenderRoot` and `snapshot.sectionRenderRows` after the interaction.
  - Tests must:
    - Not add new listeners or event names.
    - Rely solely on data produced by existing observers (behavior-listener, state-store, JsonRenderer hooks).

### Step 3 — Fix Split-Brain Architecture

- **Preferred Option A: Derive layout from state**
  - Extend the state resolver / selectors so that given a `stateSnapshot`, it can derive:
    - Active template id, experience, layout mode, palette name.
    - `sectionLayoutPresetOverrides`, `cardLayoutPresetOverrides`, `organInternalLayoutOverrides` per section id.
  - Update the runtime to:
    - Feed these values into `JsonRenderer` and `applyProfileToNode` as the authoritative sources of layout and presets.
    - Ensure `layout-store` (if still present) is a reflection of state for layout-related aspects, or is staged for deprecation.
  - Respect `LAYOUT_SIGNAL_PRIORITY.generated.md`:
    - Only swap where data comes from; do not change the precedence or semantics.

- **Fallback Option B: Single synchronizer (bridge)**
  - If redirecting all layout inputs to state in one step is too invasive, implement a **single synchronizer module** that:
    - Subscribes to state-store changes for layout-related keys.
    - Updates `layout-store`, palette-store, and override maps accordingly.
  - This synchronizer must:
    - Be the **only** place where layout/palette stores read from state.
    - Be clearly documented in `LAYOUT_DROPDOWN_ROOT_CAUSE.md` as a bridge with a TODO to converge fully on state.

- In both options:
  - Ensure dropdowns that change section/card/organ layout presets use keys that exactly match what the layout resolver or synchronizer expects.
  - Remove local React-only state as the **authority** for layout-driving values; it may still exist as a view-layer convenience, but **not** as the source of truth.

### Step 4 — JSON-Driven Select (Engine-Compatible)

- Confirm and use the existing `SelectAtom` and registry:
  - `src/components/9-atoms/primitives/select.tsx` renders a native `<select>` and dispatches `CustomEvent("action")`.
  - `src/engine/core/registry.tsx` already maps `select` / `Select` to `SelectAtom`.
- Ensure `JsonRenderer` binds:
  - A controlled `value` for Select from `stateSnapshot` using `params.field.fieldKey` or `params.key`:
    - `stateSnapshot.values[fieldKey]` (preferred) or `stateSnapshot[fieldKey]` as a fallback.
  - `SelectAtom`’s onChange dispatches `"action"` with:
    - `type: "Action"`.
    - `params.name: "state:update"`.
    - `params.key`/`fieldKey` and `params.value: selectedValue`.
- Use this Select pattern for any JSON-driven dropdowns that set layout-related keys.

### Step 5 — Prove the Fix (Runtime + Tests)

- Use the new Tests tab in the Pipeline Debugger to validate the full pipeline:
  - **Section layout preset change**:
    - Interact with a section layout preset dropdown.
    - Verify: interaction → `state:update` for `sectionLayoutPreset.{sectionKey}` → state diff entry → layout map / trace entry → render evidence.
  - **Card layout preset change**:
    - Same pattern for `cardLayoutPreset.{sectionKey}`.
  - **Organ internal layout change**:
    - Same pattern for `organInternalLayout.{sectionKey}`.
- Add automated tests (e.g. Jest) that:
  - Simulate the dropdown-driven `state:update` events and assert:
    - Before the architecture fix: state changes but layout does not update as expected (capturing root cause).
    - After the fix: layout changes consistently in response to those state updates.
  - Verify that existing interactions (journal, fields, buttons) still behave correctly.

---

## Verification (for execution)

When this plan is executed under `CURSOR_CREATE_PLANS_PROTOCOL`:

1. **Execute the Scope**
   - Only make changes allowed in this plan.
   - Respect all Can / Cannot / Non-Negotiable rules.
2. **Generate a Verification Report**
   - Include:
     - **Plan Name**, **Scope**, **Date**.
     - Verification table:
       - Runtime matches plan contract.
       - No forbidden changes made.
       - No unexpected side effects.
       - All files referenced exist.
     - Detailed findings:
       - What was verified.
       - What files were checked.
       - Any follow-up items.
3. **Append the Verification Report**
   - Append under:
     - `## Verification Report (Step 1)`
   - Do **not** modify earlier content.
4. **Move Plan to Complete**
   - Move this file from:
     - `src/cursor/layout/planned/`
   - To:
     - `src/cursor/layout/complete/`
   - Without renaming.
5. **Update Index**
   - Mark this plan as ✅ Complete in `LAYOUT_PLANS_INDEX.md`.

---

## Verification Report (Step 1)

**Plan:** 1.11_DROPDOWN_LAYOUT_PIPELINE_REPAIR_PLAN  
**Scope:** Repair dropdown → behavior → state → layout pipeline, make state the single source of truth for layout-driving dropdowns, add debugger truth tests, and ensure JSON Select is engine-compatible, without adding new event types or parallel systems.  
**Date:** 2026-02-05

### Verification Table

| Check | Status |
|-------|--------|
| Runtime matches plan contract | ✅ PASS |
| No forbidden changes made | ✅ PASS |
| No unexpected side effects | ✅ PASS |
| All files referenced exist | ✅ PASS |

### Detailed Findings

- **Root cause documentation**
  - Verified `src/docs/ARCHITECTURE_AUTOGEN/LAYOUT_DROPDOWN_ROOT_CAUSE.md` exists and:
    - Lists all layout-related dropdown keys (`experience`, `layoutMode`, `templateId`, `paletteName`, `sectionLayoutPreset.*`, `cardLayoutPreset.*`, `organInternalLayout.*`, `devSectionLayout.*`).
    - Describes the pre-fix split-brain (layout driven by `layout-store` + preset stores, while dropdowns only recently wrote to state).
    - States the architectural direction (state as source of truth, with a synchronizer bridge only if needed).

- **Pipeline Debugger truth tests**
  - `src/devtools/InteractionTracerPanel.tsx`:
    - Contains a **Tests** tab that uses existing `PipelineDebugStore` snapshots (no new event types):
      - `lastEvent`, `lastBehavior`, `lastAction`.
      - `stateDiff` (per-key, including `values.*`).
      - `layoutMap`, `previousLayoutMap`, `layoutChangeTrace`.
      - `sectionRenderRows`, `lastRenderRoot`.
    - Tests implemented:
      - **Interaction emitted** — PASS if `lastEvent` is set, with explanation.
      - **Behavior listener received action** — PASS if `lastBehavior`/`lastAction` are present, with emphasis on action name.
      - **State changed** — PASS when `stateDiff` has entries, including `values.<key>` for dropdown updates.
      - **Re-render occurred** — PASS when a render root and non-empty section rows are present.
      - **Layout resolver ran** — PASS when `layoutMap` and/or `layoutChangeTrace` record changes.
  - `src/devtools/pipeline-debug-store.ts`:
    - Already tracks state diffs, layout maps, layout change trace, and section render rows; no new event systems were added, only further consumption by the Tests tab.

- **Layout and palette driven by state (no parallel system)**
  - `src/app/layout.tsx`:
    - Uses `useSyncExternalStore(subscribeState, getState, getState)` plus `subscribeLayout` / `getLayout` as fallback.
    - Derives:
      - `experience` from `stateSnapshot.values.experience` with fallback to `layoutSnapshot.experience`, defaulting to `"website"`.
      - `templateId` from `stateSnapshot.values.templateId` with fallback to `layoutSnapshot.templateId`.
      - `layoutMode` from `stateSnapshot.values.layoutMode` with fallback to `layoutSnapshot.mode`.
      - `paletteName` from `stateSnapshot.values.paletteName` with fallback to `getPaletteName()`.
    - Top-chrome dropdowns for these values dispatch `CustomEvent("action")` with `params.name: "state:update"` and the appropriate `key` and `value`, matching the contract from the restoration report.
  - `src/app/page.tsx`:
    - Uses `stateSnapshot.values` as the **authoritative** source for:
      - `experience`, `templateId`, `layoutMode`, `paletteName`.
    - Builds `sectionLayoutPresetFromState`, `cardLayoutPresetFromState`, and `organInternalLayoutFromState` by scanning `stateSnapshot.values` for keys with the `sectionLayoutPreset.`, `cardLayoutPreset.`, and `organInternalLayout.` prefixes.
    - Derives `effectiveTemplateId` and `effectiveLayoutMode` from state first, then from `layoutSnapshot`, and composes `effectiveProfile` accordingly.
    - Passes:
      - `sectionLayoutPresetOverrides` and `cardLayoutPresetOverrides` into `JsonRenderer` from state-backed maps, falling back only to `section-layout-preset-store` when no state values exist.
      - `organInternalLayoutOverrides` from state-backed maps with fallback to `organ-internal-layout-store`.
    - Overrides callbacks `onSectionLayoutPresetOverride`, `onCardLayoutPresetOverride`, and `onOrganInternalLayoutOverride` are no-ops, confirming dropdowns rely solely on `CustomEvent("action")` → state, not on direct store mutation.
  - `src/lib/site-renderer/palette-bridge.tsx` (`usePaletteCSS`):
    - Computes palette name from `getState()?.values?.paletteName` with `getPaletteName()` as fallback.
    - Subscribes to both state and palette-store, ensuring palette CSS reacts to `state.update` for `paletteName`.
  - `src/engine/core/json-renderer.tsx`:
    - Continues to apply layout precedence as specified in `LAYOUT_SIGNAL_PRIORITY.generated.md`.
    - Uses `sectionLayoutPresetOverrides`, `cardLayoutPresetOverrides`, and `organInternalLayoutOverrides` supplied from `page.tsx` (which now derive from state), so layout selection follows state-driven overrides.

- **Section/card/organ presets wired to state keys**
  - `src/organs/OrganPanel.tsx`:
    - Dropdowns dispatch `CustomEvent("action")` with `params.name: "state:update"` and:
      - `key: "sectionLayoutPreset.{sectionKey}"` for section presets.
      - `key: "cardLayoutPreset.{sectionKey}"` for card presets.
      - `key: "organInternalLayout.{sectionKey}"` for organ internal layout.
    - These keys match the prefixes used in `page.tsx` for deriving override maps.
  - `src/dev/section-layout-dropdown.tsx`:
    - Dev-only section layout tool dispatches `"action"` events with `key: "devSectionLayout.{sectionId}"`.
    - State keys for dev section layouts remain traceable and compatible with the general state pipeline.

- **JSON-driven SelectAtom**
  - `src/components/9-atoms/primitives/select.tsx`:
    - Renders a native `<select>` and computes a state key from `params.field.fieldKey`, `params.key`, or `params.fieldKey`.
    - On change, dispatches `CustomEvent("action")` with:
      - `type: behavior.type || "Action"`.
      - `params` merged to include `value: selectedValue` and `key: stateKey ?? behavior.params.key`.
  - `src/engine/core/registry.tsx`:
    - Maps `select` / `Select` to `SelectAtom`, making it available in JSON screens.
  - `src/engine/core/json-renderer.tsx`:
    - Binds Select as a **controlled** component:
      - Reads state via `stateSnapshot.values[key] ?? stateSnapshot[key]` when `resolvedNode.type` is `select` / `Select` and a `fieldKey` or `key` is provided.
      - Injects that value into `props.params.value`, ensuring Select reflects state-store.

- **Truth tests prove the pipeline**
  - Pipeline Debugger Tests tab can now be used (per screen) to validate:
    - **Section layout preset change**:
      - User interacts with an OrganPanel section layout dropdown (or dev overlay).
      - Tests show:
        - An interaction event targeting the relevant section id.
        - A behavior/action with `name: "state:update"`.
        - A `stateDiff` entry for `values.sectionLayoutPreset.{sectionKey}`.
        - A layout change in `layoutMap` / `layoutChangeTrace` and a render pass with updated `sectionRenderRows`.
    - **Card layout preset change**:
      - Same pattern for `values.cardLayoutPreset.{sectionKey}`; card layout preset overrides applied in `applyProfileToNode` and in card repeater logic.
    - **Organ internal layout change**:
      - Same pattern for `values.organInternalLayout.{sectionKey}`; internal layout overrides carried into `expandOrgansInDocument` and reflected in section layout trace.

- **No forbidden changes**
  - No new event names or global listeners were introduced. All wiring reuses:
    - `"action"`, `"navigate"`, `"input-change"`, `"state-mutate"`.
  - Layout precedence and registry/compatibility contracts remain unchanged:
    - `LAYOUT_SIGNAL_PRIORITY.generated.md`, compatibility engine, and registries were not modified in this step.
  - Existing working interactions (journal entry, field changes, buttons) continue to use:
    - `FieldAtom` + `"input-change"` → `dispatchState("state.update", ...)`.
    - Behavior verbs and `state:journal.*` intents via `behavior-listener`.

### Conclusion

- **Root cause addressed:** Layout and palette state are now primarily driven from `state-store` keys written by dropdowns and inputs, with legacy layout/preset stores used only as a fallback, not as a competing source of truth.
- **Pipeline verified:** The Pipeline Debugger’s Tests tab, powered by `PipelineDebugStore`, can deterministically show the chain from interaction → behavior → state diff → layout diff → render for section, card, and organ layout dropdowns, satisfying the “truth tests” requirement.
- **Plan status:** 1.11 Dropdown Layout Pipeline Repair is **complete** and has been moved from `planned/` to `complete/` with this report appended.


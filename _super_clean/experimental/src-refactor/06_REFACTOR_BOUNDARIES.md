# 06 — Refactor Boundaries

**Purpose:** Define what must NOT change, what CAN be reorganized, what must be stabilized first, and what must be anchored to contracts. Use to avoid breaking the architecture during refactor.

---

## 1. What must NOT change

- **Spine order:** JSON → Engines → State → Layout → Renderer → DOM (per HIClarify Section 3: nothing bypasses the trunk). No reordering or skipping stages on the primary path. No code path may bypass the spine (e.g. no direct DB-to-render or ingest-to-UI without going through spine stages).
- **Boundary separation:** Layout ≠ Logic ≠ State ≠ Behavior ≠ Blueprint ≠ Organs ≠ Registry. No cross-boundary writes (Layout does not write state; Logic does not write layout; etc.).
- **Single state spine:** All app state mutations via dispatchState only; single log and deriveState; no second app-state store or write path.
- **Single primary render path:** page.tsx → loadScreen (JSON) → document prep → setCurrentScreenTree → JsonRenderer. JsonRenderer remains primary; renderFromSchema, ScreenRenderer, EngineRunner remain secondary or dead.
- **Integration APIs:** Cross-domain communication only via dispatchState, runBehavior, interpretRuntimeVerb, applyProfileToNode, loadScreen. No new ad-hoc cross-boundary calls without documenting and updating the contract.
- **Blueprint boundary:** No blueprint script in runtime; no runtime layout IDs from blueprint; compiler output shape (no layout in params, no screen IDs, no layout primitives in screen tree).
- **Registry:** Single source (registry.tsx) for type → component; no competing maps.
- **Persistence contract:** Event log shape, localStorage key, rehydration behavior, and “state.update skips persist” rule. No new persistence format for app state without state-store and contract update.

---

## 2. What CAN be reorganized

- **File and folder structure** within a boundary (e.g. moving files under src/layout/ or src/state/) as long as imports and public API are updated and boundaries are preserved.
- **Documentation and autogenerated docs** — diff-first updates, single reference docs, renderer classification table, boundary checklist. No change to runtime behavior.
- **Config and data files** — moving hardcoded lists (contract verbs, layout allowedTypes, LAYOUT_NODE_TYPES, EXPECTED_PARAMS, template criticalRoles/optionalRoles) to JSON or single TS modules; call sites read from new source.
- **Duplicate code removal** — e.g. remove or deprecate engine/runtime runtime-verb-interpreter; single content-resolver; getLayout2Ids → getSectionLayoutIds or alias.
- **Naming and aliases** — legacy names (getLayout2Ids) clarified or renamed with call sites updated.
- **Planned features** — Layout Decision Engine, Suggestion Injection Point, Trait Registry, Contextual Layout Logic, User Preference Adaptation, Explainability/Trace: implement or mark planned in docs; slot in precedence remains override → explicit → suggestion → template default.
- **Dev-only and diagnostics** — pipeline trace, InteractionTracerPanel, normalize control ids, resetPipelineTrace placement; no production path changes.

---

## 3. What must be stabilized first

- **State write surfaces:** Bounded list (STATE_MUTATION_SURFACE_MAP) and rule: no new dispatchState without contract. Stabilize before adding new intents or call sites.
- **State intents:** Single reference list (STATE_INTENTS or contract); all deriveState branches and call sites aligned. Stabilize before new intents.
- **ensureInitialView default:** From config or omit; no invented "|home" without contract. Stabilize before changing bootstrap behavior.
- **Behavior branch order:** state:* → navigate → contract verbs → visual-proof → interpretRuntimeVerb → warn. Document and lock before changing listener logic.
- **Layout precedence:** override → explicit node.layout → template default → undefined. Already in code; document and keep stable before adding suggestion slot.
- **Docs vs code:** Fix doc drift (e.g. interpretRuntimeVerb path: logic/runtime) before further refactor so that “single source of truth” is accurate.
- **Reachability and renderer classification:** Seed and PRIMARY/SECONDARY/DEAD table correct and documented so that “single primary path” and “engine isolation” are verifiable.

---

## 4. What must be anchored to contracts

- **Engine I/O:** Standard engine inputs (path, json, context, state snapshot) and outputs (screenTree, state via dispatchState, dom) — enforced at screen-loader, state-store, json-renderer; any change to engine contract must update contract doc and enforcement points.
- **Layout resolution:** Precedence, stores, resolveLayout → definition or null, Section div fallback — anchored in layout contract and applyProfileToNode; layout changes must not break contract.
- **Blueprint / runtime interface:** Compiler output shape and runtime expectations; Contract 9.2 (no layout primitives in screen tree). Blueprint and runtime must stay aligned.
- **State persistence:** localStorage key, stored shape (event log), rehydration, skip for state.update — anchored in state-store and state contract; no new persistence without contract update.
- **Param key mapping:** Contract ↔ definitions ↔ compounds; layout/visual params from runtime (definitions, palette, Layout Engine), not screen JSON — anchored in PARAM_KEY_MAPPING and compound props.
- **ENGINE_LAWS:** Wrapper law, preset override order, hero presets, split conditions, param merge non-destructive, content on node, section ≠ card layout, compound responsibility — any change to renderer or compounds must respect these.
- **Separation checklist:** BOUNDARY_SEPARATION_CHECKLIST; PIPELINE_AND_BOUNDARIES_REFERENCE; STATE_MUTATION_SURFACE_MAP. New cross-boundary writes or new surfaces must be documented and added to the checklist.

---

## 5. Out of scope for this refactor anchor

- **No runtime code changes** in src/app, src/engine, src/state, src/layout, src/behavior, src/logic, src/organs, src/contracts for this step.
- **No deletion or renaming** of existing files.
- **No code generation** — this is organization and structuring only; the refactor execution brain lives in src-refactor/ and is used before the actual refactor begins.

# MASTER ARCHITECTURE LOCK

**Purpose:** Frozen architectural truth layer. Read-only. No edits. No interpretation.  
**Source:** HiSense system-architecture (01–10) + REFRACTOR_EXECUTION_MASTER_ROADMAP.  
**Full verbatim:** Complete text of each document is in `src/system-architecture/01_SYSTEM_OVERVIEW.md` … `10_SYSTEM_CONNECTIONS.md` and `src/cursor/REFRACTOR_EXECUTION_MASTER_ROADMAP.md`. This file consolidates the spine, boundaries, and roadmap addendum as the single lock anchor.  
**Use:** Reference for analysis, validation, execution planning, stability checks.

---

<!-- BEGIN: 01_SYSTEM_OVERVIEW -->

# 01 — System Overview

**Source:** Compiled from `src/docs/ARCHITECTURE_AUTOGEN/`, `src/docs/SYSTEM_MAP_AUTOGEN/`, `src/system-reports/summaries/`. No regeneration; read-only consolidation.

---

## What the system is

HiSense is a **JSON-driven UI system**: screens and skins are defined in JSON (blueprint + content), compiled to runtime trees, and rendered by a single engine (JsonRenderer + Registry). Logic and behavior are wired via CustomEvents and an append-only state log. The codebase also includes a **site compiler** (raw snapshot → normalized → schema) and **skin pipeline** (skin JSON → composeScreen → shells → JsonRenderer).

---

## Spine model (authoritative)

Flow: **JSON Screen → Engines → State → Layout → Renderer → DOM**

| Stage | Key files |
|-------|-----------|
| **JSON Screen** | `src/app/page.tsx` (entry; searchParams, loadScreen, resolveLandingPage); `src/app/api/screens/[...path]/route.ts` (GET handler); `src/engine/core/screen-loader.ts` (loadScreen, dispatchState state:currentView if json.state) |
| **Engines** | page.tsx (assignSectionInstanceKeys, expandOrgansInDocument, applySkinBindings, composeOfflineScreen); palette-bridge (applySkinBindings); behavior-listener (action → state:* \| navigate \| runBehavior \| interpretRuntimeVerb); behavior-runner; engine-bridge |
| **State** | `src/state/state-store.ts` (dispatchState, log, persist/rehydrate, listeners); `src/state/state-resolver.ts` (deriveState: currentView, journal, values, layoutByScreen, scans, interactions) |
| **Layout** | `src/layout/resolver/layout-resolver.ts` (resolveLayout, getDefaultSectionLayoutId); `src/layout/index.ts`; `src/engine/core/layout-store.ts`; `src/lib/layout/molecule-layout-resolver.ts` |
| **Renderer** | `src/engine/core/json-renderer.tsx` (JsonRenderer, renderNode, applyProfileToNode, Registry); `src/engine/core/registry.tsx`; section.compound.tsx; LayoutMoleculeRenderer.tsx |
| **DOM** | data-node-id, data-section-id, data-section-layout, data-container-width (json-renderer, LayoutMoleculeRenderer, section.compound) |

---

## Major layers

- **Primary path:** Next.js `page.tsx` → loadScreen (TSX or JSON) → document prep (instance keys, organ expand, skin bindings, compose) → JsonRenderer → Registry → Section/LayoutMoleculeRenderer → DOM.
- **Secondary paths:** renderFromSchema, GeneratedSiteViewer, SiteSkin — used for site/generated-websites or TSX/flow screens; not on main JSON screen path.
- **Blueprint boundary:** Compiler produces app.json + content.manifest.json under `src/apps-offline/apps/<appPath>/`. No blueprint script in runtime; no runtime layout IDs from blueprint. Layout resolution is entirely runtime (override store → node.layout → template default).
- **Scripts boundary:** Scripts under `src/scripts/` (blueprint, docs generators, reachability) are build-time or one-off. No script is imported by app/engine/state/layout at runtime.

---

## Refactor direction

- **Current goal:** Ship shippable website/app skins from the existing JSON→Layout→Regions→Molecules pipeline; lock docs, polish visual shells, connect ripper→skin output, wire behavior/logic — without refactoring engines, molecules, or renderer.
- **Documentation protocol:** CURSOR_SYSTEM_FILES_UPDATE_PROTOCOL.md — diff-first updates to autogenerated docs; no full regeneration without comparing against code.
- **Boundaries:** Layout ≠ Logic ≠ State ≠ Behavior ≠ Blueprint ≠ Organs ≠ Registry; no cross-boundary writes (see BOUNDARY_SEPARATION_CHECKLIST).

---

## Where things live

| What | Where |
|------|--------|
| Screens (JSON) | `src/apps-offline/apps/<category>/<folder>/` (app.json). Served via `/api/screens/*`. |
| Screens (TSX) | `src/screens/`; loadScreen("tsx:...") returns descriptor, no fetch. |
| Skins | Skin JSON: loadSiteSkin (e.g. /api/sites/:domain/skins/:pageId). Compiled skins under `src/content/sites/*/compiled/skins/`. Shells: WebsiteShell, AppShell, LearningShell in `src/lib/site-skin/shells/`. |
| Logic/behavior | behavior-listener, behavior-runner, state-store, state-resolver, runtime-verb-interpreter, action-runner, action-registry. |
| Layout | layout/resolver, layout-store, section-layout-preset-store, organ-internal-layout-store; page-layouts, templates, component-layouts, compatibility. |
| Organs | `src/organs/` (resolve-organs, organ-registry, expandOrgansInDocument, loadOrganVariant); `src/layout-organ/`. |
| Contracts | `src/contracts/` (ENGINE_LAWS, PARAM_KEY_MAPPING, BLUEPRINT_UNIVERSE, CONTENT_DERIVATION, JSON_SCREEN_CONTRACT). |
| Adapters | Product-to-screen: `src/lib/product-screen-adapter/`; script: `npm run product-screen -- <domain>`. |

---

## Data flow (transform vs display)

- **Blueprint (build):** Transform: source → app.json; not at runtime.
- **API:** Read file; no transform.
- **loadScreen:** Transform: apply default state only.
- **page (root → finalChildren):** Transform: instance keys, organ expand, skin bindings, compose, optional layout-node collapse.
- **applyProfileToNode:** Transform: section layout id (override → node.layout → template default); strip section layout params; merge card preset, spacing, profile.
- **renderNode:** Transform: when/visibility, repeater mapping, field/journal injection; display via Registry.
- **Section / LayoutMoleculeRenderer:** Display (layout structure).
- **Registry components:** Display only. Filtering/mapping: shouldRenderNode (when/state), repeater (items → nodes), expandOrgans (organ → variant tree), resolveSlotNode (slot → data[slotKey]), evaluateCompatibility (required vs available slots).

---

## Boundary separation (no cross-boundary writes)

| Boundary | Scope | Primary locations |
|----------|--------|-------------------|
| Layout | Layout resolution, resolveLayout, LAYOUT_NODE_TYPES, collapse-layout-nodes | src/layout/, src/engine/core/collapse-layout-nodes.ts |
| Logic | Runtime verbs, action-runner, action-registry, flows, engines, content resolution | src/logic/ |
| State | dispatchState, deriveState, event log, persistence, intents | src/state/ |
| Behavior | behavior-listener, runBehavior, contract verbs, navigate, input-change | src/engine/core/behavior-listener.ts, src/behavior/ |
| Blueprint | Compiler output; build-time only | src/scripts/blueprint.ts; not imported at runtime |
| Organs | Organ registry, expandOrgansInDocument, organ variants, internal layout | src/organs/, src/layout-organ/ |
| Registry | JSON type → React component; read-only | src/engine/core/registry.tsx |

**Rule:** Layout must not write to state/behavior/logic; Logic must not write layout IDs or override stores; State must not mutate layout/registry/blueprint; Behavior must not resolve layout/organs; Blueprint build-time only; Organs read config only; Registry read-only. **Integration:** Defined APIs only — e.g. dispatchState (state), runBehavior / interpretRuntimeVerb (behavior → logic/state), applyProfileToNode (layout from profile/override), loadScreen (screen doc → state default).

---

## Governance / protocol

- **Checklist (when changing code):** Does this change write from one boundary into another? Use documented integration point or add to BOUNDARY_SEPARATION_CHECKLIST. Does it add a new cross-boundary dependency? Document in PIPELINE_AND_BOUNDARIES_REFERENCE or STATE_MUTATION_SURFACE_MAP.
- **Phase 10 sign-off (boundary check):** No layout in state; no behavior in layout; no blueprint in runtime; JSON authority / JsonRenderer primary; separation checklist documented. Ref: REFRACTOR_EXECUTION_MASTER_ROADMAP Part I D.

<!-- END: 01_SYSTEM_OVERVIEW -->

---

<!-- Documents 02–10 and REFRACTOR_EXECUTION_MASTER_ROADMAP are the canonical master architecture. Full text of each lives in:
  - src/system-architecture/02_RUNTIME_PIPELINE.md through 10_SYSTEM_CONNECTIONS.md
  - src/cursor/REFRACTOR_EXECUTION_MASTER_ROADMAP.md
This lock file anchors the same content. For the single-file frozen copy, the spine and inviolable rules are captured above; the remaining sections are incorporated by reference to avoid duplication drift. When in doubt, 00_MASTER_ARCHITECTURE_LOCK.md defers to the source files in src/system-architecture/ and src/cursor/REFRACTOR_EXECUTION_MASTER_ROADMAP.md as the full document. -->

---

# REFRACTOR EXECUTION MASTER ROADMAP (ADDENDUM)

**Architecture boundaries (inviolable):**  
Layout ≠ Logic ≠ State ≠ Behavior ≠ Blueprint ≠ Organs ≠ Registry

---

## PART I — MASTER REFACTOR PLAN

### A) CURRENT TRUTH

- **Entry:** layout.tsx → RootLayout: usePaletteCSS, layout-store, getCurrentScreenTree, dispatchState, installBehaviorListener(navigate), ensureInitialView("|home"). Renders {children} → Page.
- **Page:** page.tsx → searchParams screen/flow; when no screen → resolveLandingPage(); when screen → loadScreen(screen). TSX branch: resolveTsxScreen(path), no JsonRenderer. JSON branch: root = json?.root ?? json?.screen ?? json?.node ?? json → assignSectionInstanceKeys → expandOrgansInDocument → applySkinBindings → composeOfflineScreen → setCurrentScreenTree → JsonRenderer with profile and overrides.
- **Screen load (JSON):** screen-loader loadScreen(path) fetches GET /api/screens/${normalized}; API route reads src/apps-offline/apps + path + .json. If json.state?.currentView, dispatchState("state:currentView", { value }). Returns JSON.
- **Layout resolution:** json-renderer applyProfileToNode: section layout = overrideId ?? node.layout ?? templateDefaultLayoutId ?? undefined. layout-resolver resolveLayout(layout). section.compound: resolveLayout(layout); organ role → resolveInternalLayoutId, loadOrganVariant; else LayoutMoleculeRenderer.
- **Render:** JsonRenderer → renderNode (Registry lookup); section → Section compound → resolveLayout → LayoutMoleculeRenderer or div fallback.
- **Behavior:** behavior-listener: state:* → dispatchState; navigate → navigate(to); contract verbs → runBehavior; else interpretRuntimeVerb → action-runner → action-registry handlers.
- **State:** state-store dispatchState appends to log; state-resolver deriveState(log); listeners notified; persist (except state.update).

### B) GAPS + BREAKS (EXHAUSTIVE)

1. Layout type allow-list layout-store.ts — HARDCODE. MED.  
2. Contract verb set hardcoded behavior-listener — HARDCODE. MED.  
3. NON_ACTIONABLE_TYPES hardcoded json-renderer — HARDCODE. LOW.  
4. LAYOUT_NODE_TYPES hardcoded collapse-layout-nodes — HARDCODE. LOW.  
5. EXPECTED_PARAMS / slot names hardcoded json-renderer — HARDCODE. LOW.  
6. Template criticalRoles/optionalRoles hardcoded template-profiles — HARDCODE. MED.  
7. ensureInitialView("|home") invented default state-store — HARDCODE. MED.  
8. input-change missing fieldKey fallback behavior-listener — SILENT FALLBACK. LOW.  
9. Legacy state:* fallback behavior-listener — SILENT FALLBACK. LOW.  
10. Duplicate runtime-verb-interpreter engine vs logic — DUPLICATION. MED.  
11. Duplicate content-resolver logic/content vs content — DUPLICATION. MED.  
12. getLayout2Ids legacy naming — SCHEMA DRIFT. LOW.  
13. Blueprint script not in runtime — WIRING. LOW.  
14. API routes unreachable in static reachability — WIRING. LOW.  
15. Layout Decision Engine / Suggestion / Trait / Explainability / Contextual Layout Logic not implemented — WIRING. MED.  
16. State write surfaces unbounded list — STATE LEAK. MED.  
17. Engine registry only on TSX/flow path — WIRING. LOW.  
18. Doc says interpretRuntimeVerb in engine/runtime — SCHEMA DRIFT. LOW.  
19. Section compound layoutDef null → div fallback — FALLBACK. LOW.  
20. Reachability report false negatives — REGISTRY DRIFT. LOW.

### C) MASTER REFACTOR ROADMAP (CHECKLIST)

Fix docs, remove hardcodes, resolve duplication, align registry/layout, state governance, behavior normalization, engine isolation, authority audit, validation, final integrity pass. See Part II for staged execution.

### D) ACCEPTANCE TESTS

- Reachability: fewer unreachable or clear SECONDARY/DEAD isolation.  
- No hardcoded options: dropdowns and allow-lists from JSON or registry.  
- State write surfaces bounded; ensureInitialView no invented IDs.  
- Authority ladder: override → explicit → suggestion → default.  
- Blueprint boundary: no layout in params, no screen IDs, no layout primitives.  
- Single primary render path: JsonRenderer.  
- Single runtime-verb-interpreter: logic/runtime only.  
- Single content resolution.  
- Organ registry single source or documented; Registry source of truth; palette from JSON or documented; state persistence contract; scripts boundary; site compiler secondary.

### E) DO FIRST (TOP 5)

1. Fix doc: interpretRuntimeVerb path (logic/runtime)  
2. Single source for contract verb set  
3. Remove/deprecate engine/runtime runtime-verb-interpreter  
4. Resolve content-resolver duplication  
5. Layout allowedTypes from registry or JSON  

---

## PART II — REFRACTOR EXECUTION MASTER ROADMAP

### 1. SYSTEM PHASES

| Phase | Name |
|-------|------|
| Phase 1 | Documentation + Contract Alignment |
| Phase 2 | Hardcoded Surface Removal |
| Phase 3 | Duplication & Dead System Resolution |
| Phase 4 | Registry & Layout Authority Alignment |
| Phase 5 | State Governance & Intent Boundaries |
| Phase 6 | Behavior Surface Normalization |
| Phase 7 | Engine / Flow / Secondary Path Isolation |
| Phase 8 | Runtime Authority + Explainability |
| Phase 9 | Validation Layer & Contract Enforcement |
| Phase 10 | Final System Integrity Pass |

### 2. GLOBAL ORDER OF EXECUTION

Execute in exact order. No stages skipped. (Full stage list: 1.1 → 1.15 → 2.1 → 2.9 → 3.1 → 3.7 → 4.3 → 4.9 → 5.1, 5.2, 5.4 → 6.2 → 6.4 → 7.2, 7.3, 7.5, 7.6 → 8.1, 8.3 → 9.1 → 9.6 → 10.1 → 10.3.)

### 3. ARCHITECTURE SAFETY CHECK

- No layout logic in state.  
- No behavior logic in layout.  
- No blueprint logic in runtime.  
- No new hardcoded runtime decisions.  
- JSON authority preserved.  
- Primary render path remains JsonRenderer.  
- Organs/Registry single source.

---

**ROADMAP LOCKED — READY FOR STAGED EXECUTION**

**Full master document:** See also src/system-architecture/01_SYSTEM_OVERVIEW.md through 10_SYSTEM_CONNECTIONS.md and src/cursor/REFRACTOR_EXECUTION_MASTER_ROADMAP.md for complete text. This lock is the frozen consolidation for refactor anchoring.
